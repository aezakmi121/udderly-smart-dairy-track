import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { inr, inrShort, fmtDate, fmtMonth } from './format';

export interface PdfData {
  fromDate: string;
  toDate: string;
  reportType: 'accrual' | 'cashflow';
  totalExpenses: number;
  averagePerMonth: number;
  recordsCount: number;
  categoryBreakdown: Array<{ name: string; amount: number; percentage: number }>;
  monthlyTrends: Array<{ month: string; amount: number }>;
  paymentMethods: Array<{ name: string; amount: number }>;
  sourceBreakdown: Array<{
    name: string;
    amount: number;
    count: number;
    categories: Array<{ name: string; amount: number; count: number }>;
  }>;
  transactions: Array<{
    date: string;
    amount: number;
    category: string;
    source: string;
    paymentMethod: string;
    vendor: string;
    paidBy: string;
    description: string;
    status?: string;
  }>;
  images: {
    categoryDonut: string;
    monthlyTrends: string;
    paymentBars: string;
    drilldowns: Array<{ category: string; image: string }>;
  };
}

export const generateExpenseReportPDF = (data: PdfData): jsPDF => {
  const doc = new jsPDF('p', 'mm', 'a4');
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 20;
  let pageNumber = 1;

  // Helper: Add header to page
  const addHeader = () => {
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.text('Expense Report', margin, 15);

    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    const reportTypeText = `Report Type: ${data.reportType === 'accrual' ? 'Accrual' : 'Cashflow'}`;
    const rangeText = `Range: ${fmtDate(data.fromDate)} → ${fmtDate(data.toDate)}`;
    doc.text(reportTypeText, pageWidth - margin, 12, { align: 'right' });
    doc.text(rangeText, pageWidth - margin, 17, { align: 'right' });
  };

  // Helper: Add footer to page
  const addFooter = (currentPage: number, totalPages: number) => {
    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(128, 128, 128);
    doc.text('Generated by Maharani Dairy', margin, pageHeight - 10);
    doc.text(`Page ${currentPage} / ${totalPages}`, pageWidth - margin, pageHeight - 10, { align: 'right' });
    doc.setTextColor(0, 0, 0);
  };

  // === PAGE 1: KPI Summary + Category Donut ===
  addHeader();

  // KPI Cards in 2x2 grid
  let yPos = 28;
  const cardWidth = (pageWidth - 3 * margin) / 2;
  const cardHeight = 20;

  // Top row
  doc.setDrawColor(200, 200, 200);
  doc.setLineWidth(0.3);
  doc.rect(margin, yPos, cardWidth, cardHeight);
  doc.rect(margin + cardWidth + margin / 2, yPos, cardWidth, cardHeight);

  doc.setFontSize(10);
  doc.setTextColor(100, 100, 100);
  doc.text('Total Expenses', margin + 3, yPos + 6);
  doc.text('Average / Month', margin + cardWidth + margin / 2 + 3, yPos + 6);

  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text(inr(data.totalExpenses), margin + 3, yPos + 14);
  doc.text(inr(data.averagePerMonth), margin + cardWidth + margin / 2 + 3, yPos + 14);

  // Bottom row
  yPos += cardHeight + 5;
  doc.setFont('helvetica', 'normal');
  doc.rect(margin, yPos, cardWidth, cardHeight);
  doc.rect(margin + cardWidth + margin / 2, yPos, cardWidth, cardHeight);

  doc.setFontSize(10);
  doc.setTextColor(100, 100, 100);
  doc.text('Records', margin + 3, yPos + 6);
  doc.text('Range Type', margin + cardWidth + margin / 2 + 3, yPos + 6);

  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text(String(data.recordsCount), margin + 3, yPos + 14);
  doc.text(data.reportType === 'accrual' ? 'Accrual' : 'Cashflow', margin + cardWidth + margin / 2 + 3, yPos + 14);

  // Category Distribution Donut Chart
  yPos += cardHeight + 15;
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(12);
  doc.text('Category-wise Distribution', margin, yPos);
  yPos += 5;

  if (data.images.categoryDonut) {
    const imgWidth = pageWidth - 2 * margin;
    const imgHeight = 100; // Adjust based on your chart aspect ratio
    doc.addImage(data.images.categoryDonut, 'PNG', margin, yPos, imgWidth, imgHeight);
    yPos += imgHeight + 10;
  }

  // Add page footer
  addFooter(pageNumber, 1); // Will update total pages later

  // === PAGE 2: Monthly Trends + Payment Method Bars ===
  doc.addPage();
  pageNumber++;
  addHeader();
  yPos = 28;

  // Monthly Trends Area Chart
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(12);
  doc.text('Monthly Expense Trends', margin, yPos);
  yPos += 5;

  if (data.images.monthlyTrends) {
    const imgWidth = pageWidth - 2 * margin;
    const imgHeight = 70;
    doc.addImage(data.images.monthlyTrends, 'PNG', margin, yPos, imgWidth, imgHeight);
    yPos += imgHeight + 15;
  }

  // Payment Methods Bar Chart
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(12);
  doc.text('Payment Methods Breakdown', margin, yPos);
  yPos += 5;

  if (data.images.paymentBars) {
    const imgWidth = pageWidth - 2 * margin;
    const imgHeight = 70;
    doc.addImage(data.images.paymentBars, 'PNG', margin, yPos, imgWidth, imgHeight);
  }

  addFooter(pageNumber, 1);

  // === PAGES 3..N: Source Drilldowns (Category-wise) ===
  if (data.images.drilldowns && data.images.drilldowns.length > 0) {
    const categoriesPerPage = 2;
    
    for (let i = 0; i < data.images.drilldowns.length; i += categoriesPerPage) {
      doc.addPage();
      pageNumber++;
      addHeader();
      yPos = 28;

      // Add up to 2 categories per page
      const pageCategories = data.images.drilldowns.slice(i, i + categoriesPerPage);
      
      pageCategories.forEach((drilldown, idx) => {
        const categoryData = data.categoryBreakdown.find(c => c.name === drilldown.category);
        
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(14);
        doc.setTextColor(41, 128, 185);
        doc.text(`Source Distribution - ${drilldown.category}`, margin, yPos);
        doc.setTextColor(0, 0, 0);
        yPos += 5;

        if (categoryData) {
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(9);
          doc.setTextColor(100, 100, 100);
          doc.text(
            `Total: ${inr(categoryData.amount)} | ${categoryData.percentage.toFixed(1)}% of total expenses`,
            margin,
            yPos
          );
          doc.setTextColor(0, 0, 0);
          yPos += 5;
        }

        if (drilldown.image) {
          const imgWidth = pageWidth - 2 * margin;
          const imgHeight = 80;
          doc.addImage(drilldown.image, 'PNG', margin, yPos, imgWidth, imgHeight);
          yPos += imgHeight + 15;
        }
      });

      addFooter(pageNumber, 1);
    }
  }

  // === FINAL PAGE: Transactions Table ===
  doc.addPage();
  pageNumber++;
  addHeader();
  yPos = 28;

  doc.setFont('helvetica', 'bold');
  doc.setFontSize(12);
  doc.text('Transaction Details', margin, yPos);
  yPos += 3;

  if (data.transactions && data.transactions.length > 0) {
    const tableData = data.transactions.map(txn => [
      data.reportType === 'accrual' ? fmtMonth(txn.date) : fmtDate(txn.date),
      txn.description || 'N/A',
      txn.category,
      txn.source,
      txn.vendor,
      txn.paymentMethod,
      txn.paidBy,
      inrShort(txn.amount),
      txn.status || 'N/A'
    ]);

    autoTable(doc, {
      startY: yPos,
      head: [['Date', 'Description', 'Category', 'Source', 'Vendor', 'Method', 'Paid By', 'Amount', 'Status']],
      body: tableData,
      foot: [[
        { content: 'TOTAL', colSpan: 7, styles: { halign: 'right', fontStyle: 'bold' } },
        { content: inr(data.totalExpenses), styles: { fontStyle: 'bold', halign: 'left' } },
        ''
      ]],
      theme: 'grid',
      headStyles: {
        fillColor: [220, 220, 220],
        textColor: [0, 0, 0],
        fontStyle: 'bold',
        fontSize: 8
      },
      styles: {
        fontSize: 7,
        cellPadding: 2,
        overflow: 'linebreak',
        cellWidth: 'wrap'
      },
      columnStyles: {
        0: { cellWidth: 22 },
        1: { cellWidth: 30 },
        2: { cellWidth: 20 },
        3: { cellWidth: 20 },
        4: { cellWidth: 20 },
        5: { cellWidth: 18 },
        6: { cellWidth: 18 },
        7: { cellWidth: 20, halign: 'right' },
        8: { cellWidth: 15 }
      },
      alternateRowStyles: {
        fillColor: [245, 245, 245]
      },
      didDrawPage: (data) => {
        // Add header and footer on each page of the table
        if (data.pageNumber > 1) {
          addHeader();
        }
        addFooter(pageNumber + (data.pageNumber - 1), 1);
      }
    });

    // Update page number after table
    const finalY = (doc as any).lastAutoTable.finalY;
    pageNumber += Math.floor((finalY - yPos) / (pageHeight - 40));
  } else {
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(10);
    doc.text('No transactions found for the selected period.', margin, yPos + 10);
  }

  // Update all page numbers with correct total
  const totalPages = pageNumber;
  for (let i = 1; i <= totalPages; i++) {
    doc.setPage(i);
    // Clear old footer area
    doc.setFillColor(255, 255, 255);
    doc.rect(0, pageHeight - 15, pageWidth, 15, 'F');
    // Redraw footer with correct page numbers
    addFooter(i, totalPages);
  }

  return doc;
};

/**
 * Generate WhatsApp summary message
 */
export const generateExpenseWhatsAppMessage = (data: {
  fromDate: string;
  toDate: string;
  reportType: 'accrual' | 'cashflow';
  totalExpenses: number;
  averagePerMonth: number;
  recordsCount: number;
  categoryBreakdown: Array<{ name: string; amount: number; percentage: number }>;
  sourceBreakdown: Array<{ name: string; amount: number }>;
}): string => {
  const reportTypeName = data.reportType === 'accrual' ? 'Accrual' : 'Cashflow';
  
  let message = `*Expenses — ${reportTypeName}*\n`;
  message += `Range: ${fmtDate(data.fromDate)} → ${fmtDate(data.toDate)}\n`;
  message += `Total: ${inr(data.totalExpenses)} | Avg/Month: ${inr(data.averagePerMonth)} | Records: ${data.recordsCount}\n\n`;
  
  message += `*Top Categories:*\n`;
  const topCategories = data.categoryBreakdown.slice(0, 3);
  topCategories.forEach((cat, idx) => {
    message += `${idx + 1}) ${cat.name} — ${cat.percentage.toFixed(1)}% (${inr(cat.amount)})\n`;
  });
  
  message += `\n*Top Sources:*\n`;
  const topSources = data.sourceBreakdown.slice(0, 3);
  topSources.forEach((src) => {
    message += `${src.name} — ${inr(src.amount)}\n`;
  });
  
  return message;
};
